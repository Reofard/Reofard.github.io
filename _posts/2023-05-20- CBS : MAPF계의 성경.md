---
title:  "CBS : MAPF계의 성경"
excerpt: "Robot"

categories:
  - Path_Finding

tags:
  - [MAPF, Path Finding, Multi-Robot]

toc: true
toc_sticky: true
layout: post
use_math: true
 
date: 2023-05-20
last_modified_at: 2023-05-20
---

# **Conflict-based search for optimal multi-agent pathfinding**

MAPF에서 유명한 알고리즘인 Conflict-Based Search 줄여서 CBS 알고리즘에 대해 정리해보려고 한다. 논문 저자를 보니까 ICTS 저자와 동일하신 분이시던데 정말 대단하신것 같다. 아무튼 CBS알고리즘은 파생 알고리즘도 많고, 범용적으로 쓰이기 쉬운 구조를 갖고있는데, 자세하게 정리해보자. 참고 자료는 [Conflict-based search for optimal multi-agent pathfinding 논문](https://www.sciencedirect.com/science/article/pii/S0004370214001386?ref=pdf_download&fr=RR-2&rr=8be4e8d2d984a7d8)이다.

<br>

## **간단한 소개**

**Conflict Based Search**알고리즘은 MAPF 문제를 optimal 하게 해결하기 위한 알고리즘이다. 즉 해당 검색 알고리즘의 비용함수를 최소화하는 solution을 찾아내는 함수인데, 앞서 다뤘던 **[ICTS](https://reofard.github.io/path_finding/2023/05/07/ICTS-%EC%B5%9C%EC%A0%81%EC%9D%98-%EA%B2%BD%EB%A1%9C-%EC%A1%B0%ED%95%A9%EC%9D%84-%EC%B0%BE%EC%95%84%EB%B3%B4%EC%9E%90!.html)**와는 다른 접근방식을 통해 문제를 해결한다. ICTS는 모든 비용 조합에 따른 경로 조합을 모두 비교해보는 방식으로 솔루션을 찾아내지만, **CBS**는 감지된 충돌을 기반으로 제약조건을 생성하고, 제약조건의 조합을 찾아내는 방식으로 솔루션을 찾아낸다. 즉 이전의 방식들과 달리 MAPF를 CBS는 MAPF를 제약된 다수의 **single agent path finding** 문제로 분해하여 해결한다. 이러한 방법은 기존의 경로조합이나, 경로 비용조합을 탐색하는 것과 다른 상태공간을 탐색하기 때문에 기존의 알고리즘보다 보편적으로 더 우수하다고 한다.

CBS 알고리즘은 이렇게 MAPF를 다수의 **single agent path finding**문제로 분해하여 solution을 계산하기 위해 single agent path finding에서 충돌을 회피하는 $constraint$를 생성한다. 그렇기 때문에 CBS알고리즘은 ICTS와 마찬가지로 $constraint$의 조합을 탐색하는 **High level Search**와 single agent path finding을 탐색하는 **Low level Search**로 구성된 구조를 갖는다.

<br>

## **1. 정의**

CBS의 정의부터 간단하게 정리하고 넘어가자. 일단 CBS에서의 입력과 출력은 classical MAPF의 정의를 따른다.

먼저 $path$는 단일 agent의 경로인 $\pi_i$를 나타낸다. 또한 $solution$은 주어진 $k$개의 agent에 대한 $k$개의 경로로 구성된 집합을 의미한다. 즉 [Classical MAPF](https://reofard.github.io/path_finding/2023/04/22/MAPF%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C.html)에서의 정의를 그대로 사용한다.

CBS에서 가장 중요한 개념은 $conflict$와 $constraint$이다. 우선 $conflict$는 아래 식과 같은 튜플로 나타내지는 특정 agent간의 충돌을 나타내는 값이다.

$$
\begin{aligned}
vertex\ conflict &= (a_i, a_j, v, t) \\
edge\ conflict  &= (a_i, a_j, v_1. v_2, t)\\
\end{aligned}
$$

하나의 $solution$안에서 각 $path$를 비교하여 $conflict$를 찾고, $conflict$가 발견되면 그 $solution$은 무효화 된다.

$constraint$는 single agent path finding 연산에서 $conflict$를 회피하기 위해 사용되는 값이다. $conflict$에서 파생되는 값이며, 아래 식과 같이 튜플로써 정의된다.

$$
\begin{aligned}
vertex\ constraint &= (a_i, v, t) \\
edge\ constraint  &= (a_i, v_1. v_2, t)\\
\end{aligned}
$$

$conflict$는 특정 $solution$에서 두 agent $a_i$와 $a_j$가 부딫치는 시간과 장소에 대한 정보이고, $constraint$는 $conflict$에서 파생되어 agent $a_i$가 특정 시간 및 장소에서 충돌을 할 수 있다는 제약조건이다. 즉 하나의 $conflict$에 두개의 $constraint$가 파생될 수 있는 것이다.

## **2. High-level Search**

High level Search에서 CBS알고리즘은 $constraint\ tree$(이하 CT)라는 2진 트리를 탐색한다. CT의 노드 $N$은 다음과 같은 요소로 구성된다.

1. $N.constraints$ : $constraint$의 집합으로 각각의 $constraint$는 하나의 agent에 귀속되어있다. Root CT Node는 해당 집합이 공집합이고, 각 child CT Node는 부모의 $N.constraints$에 추가로 새로운 $constraint$ 하나를 상속받는다.

2. $N.solution$ : 각 CT Node마다 갖는 $solution$으로 모든 $path$가 $N.constraints$에 만족하는 경로이다. 각 $path$는 $N.constraints$를 parent node로 부터 상속 받을 때 Low-level Search를 통해 계산된다.

3. $N.cost$ : $N.solution$의 전체 비용이다. 탐색 알고리즘 조건 중 $f$-value에 해당한다.

CT는 Best fit Search로 검색을 하고, $f$-value가 낮은 노드부터 검색한다. 그렇다면 CT는 어떤방식으로 전개되며 상태공간을 탐색할 수 있을까? 아래부터 자세히 알아보도록 하자.

![Conflict based Search](/assets/img/ConflictBasedSearch.png)

위 사진은 CT가 어떻게 전개되고, 탐색되는지 보여주는 간단한 그림이다. 우선 처음에 CT의 Root Node는 Con(=$N.constraints$)를 공집합으로 갖는다. 이렇게 $N.constraints$가 정해지면, Low-level Search를 통해 각 agent마다 제약조건에 맞는 $\pi_i$를 계산하여 Sol(=$N.solution$)을 구한다. 위 사진에서는 Root Node에서 경로가 아래 식과 같은 값이 나온거다.

$$
\begin{aligned}
\pi_1 &= (S1, A1, D, G1) \\
\pi_2  &= (S2, B1, D, G2)\\
\end{aligned}
$$

이제 제약 조건에 따른 모든 agent의 경로가 구해졌으니 충돌을 검사한다. 각 충돌은 위에서 정의한 바와 같이 vertex, edge conflict를 사용하여 계산한다. 위 경로에 대해 충돌은 아래 식과 같이 검출된다.

$$
\begin{aligned}
confs &= \{(1, 2, D, 2)\} \\
\end{aligned}
$$

$\pi_1$과 $\pi_2$의 사이의 충돌은 2번째 timestep에서 D위치에서 서로 같은 노드 D를 점유하게 되기 때문에 위 식과 같이 나타낼 수 있다. 하나에 $N.solution$에는 여러 conflict가 존재 할 수 있다. 위에서 정의한 충돌 $confs[0]$은 다시 아래 식과 같이 constraint 2개로 나눠질 수 있다.

$$
\begin{aligned}
const_{0-1} &= (1, D, 2) \\
const_{0-2} &= (2, D, 2)\\
\end{aligned}
$$

위의 식과 같이 파생된 $constraint$ 쌍은 각각 child node에 parent node의 Con(=$N.constraints$)에 더해져 상속되며 CT가 전개된다. 하나의 $solution$에서 검출된 충돌이 여러개일 경우 2개 이상의 $conflict$가 여러개의 $constraint$가 생성 될 수 있다. 이 경우 해당 논문에서는 가장 첫번째로 발생하는 $conflict$에 대해서만 $constraint$를 전개하거나, 모든 $conflict$에 대해 constraint를 전개하여 충돌의 갯수에 따라 child를 많이 생성하는 방식으로 총 두가지 방식을 제안하는데, 최초로 발생하는 $conflict$만 $constraint$로 전개하는 방식이 더 좋아보인다. constraint가 걸린 시점 이후 경로는 모두 바뀔 수 있기 때문이다.

이렇게 Parent Node에서 Child Node로 $constraint$가 상속된 이후 다시 Low-level Search를 통해 새로운 $N.constraints$에 만족하는 $N.solution$을 계산하고 $conflict$ 검출, $constraint$ 전개를 통해 child node에서 다시 CT를 전개해 나간다.

이렇게 CT를 탐색하다가 $conflict$가 검출되지 않으면 해당 노드의 $N.solution$이 output으로 반환된다.

CT 탐색 알고리즘은 Best-fit Search 알고리즘을 통해 이뤄지는 데 이는 Priority-Queue인 Open-List와 Close-List로 구현된다. 간단한 설명으로는 먼저 Open-List에서 $f$-value가 가장 낮은 Node $N$을 선택하여 꺼내고, $N.conflict$를 이용해 child Node $N_1$과 $N_2$를 전개한다. 이후 $N_1$과 $N_2$를 Open-List에 넣고 앞선 과정을 반복하게 된다. 해당 로직은 아래 pseudo-code이다. 해당 예시 코드는 CBS뿐 아니라 이후에 소개할 Meta Agent CBS의 로직도 담고있는데, 11~18 Line을 제외하고 보면 된다.

![Conflict based Search](/assets/img/CBS_pseudo_code.png)

<br>

## **3. Low-level Search**

이번 섹션에서는 CT를 탐색하며 구한 $N.constraints$에 맞는 경로는 어떻게 계산하는지 정리해보려고 한다. 먼저 Low-level Search의 입력은 

### conflict avoidance table (CAT)

<br>

## **4. Optimality of CBS**

그렇다면 CBS알고리즘의 결과가 최적임은 어떻게 증명할까?

<br>

## **후기**

내용